<!DOCTYPE html>
<html>
<head>
    <title>Infrastructure Architecture Server-side Service Discovery</title>
    <link rel="stylesheet" href="styles/site.css" type="text/css" />
    <META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</head>
<body class="theme-default aui-theme-default">
    <div id="page">
        <div id="main" class="aui-page-panel">
            <div id="main-header">
                <div id="breadcrumb-section">
                    <ol id="breadcrumbs">
                        <li>
                            <a href="index.html">Information Technology</a>
                        </li>
                        <li>
                            <a href="2.0-Architectures_451824369.html">2.0 Architectures</a>
                        </li>
                        <li>
                            <a href="451820182.html">Microservices &amp; Distributed System</a>
                        </li>
                        <li>
                            <a href="Microservice-Architecture_451820190.html">Microservice Architecture</a>
                        </li>
                    </ol>
                </div>
                <h1 id="title-heading" class="pagetitle">

                    Infrastructure Architecture Server-side Service Discovery

                </h1>
            </div>
            <div id="content" class="view">
                <h2>Context</h2>
                <p>
                    Services typically need to call one another. In a monolithic application, services invoke one another through language-level method or procedure calls. In a traditional distributed system deployment, services run at fixed, well known locations (hosts and ports) and so can easily call one another using HTTP/REST or some RPC mechanism. However, a modern 
                    <a style="text-decoration: none;" href="https://microservices.io/patterns/microservices.html" class="external-link" rel="nofollow">microservice-based</a> application typically runs in a virtualized or containerized environments where the number of instances of a service and their locations changes dynamically.
                </p>
                <p style="margin-left: 30.0px;">
                    <img class="confluence-embedded-image img-responsive confluence-external-resource confluence-content-image-border" height="250" src="https://microservices.io/i/servicediscovery/discovery-problem.jpg" data-image-src="https://microservices.io/i/servicediscovery/discovery-problem.jpg">
                </p>
                <p>Consequently, you must implement a mechanism for that enables the clients of service to make requests to a dynamically changing set of ephemeral service instances.</p>
                <h2>Problem</h2>
                <p>How does the client of a service - the API gateway or another service - discover the location of a service instance?</p>
                <h2>Forces</h2>
                <ul>
                    <li>Each instance of a service exposes a remote API such as HTTP/REST, or Thrift etc. at a particular location (host and port)</li>
                    <li>The number of services instances and their locations changes dynamically.</li>
                    <li>Virtual machines and containers are usually assigned dynamic IP addresses.</li>
                    <li>The number of services instances might vary dynamically. For example, an EC2 Autoscaling Group adjusts the number of instances based on load.</li>
                </ul>
                <h2>Solution</h2>
                <p>
                    When making a request to a service, the client makes a request via a router (a.k.a load balancer) that runs at a well known location. The router queries a 
                    <a href="https://microservices.io/patterns/service-registry.html" style="text-decoration: none;" class="external-link" rel="nofollow">service registry</a>, which might be built into the router, and forwards the request to an available service instance.
                </p>
                <p>The following diagram shows the structure of this pattern.</p>
                <p style="margin-left: 30.0px;">
                    <img class="confluence-embedded-image img-responsive confluence-external-resource confluence-content-image-border" height="250" src="https://microservices.io/i/servicediscovery/server-side-discovery.jpg" data-image-src="https://microservices.io/i/servicediscovery/server-side-discovery.jpg">
                </p>
                <h2>Examples</h2>
                <p>
                    An AWS Elastic Load Balancer (ELB) is an example of a server-side discovery router. A client makes HTTP(s) requests (or opens TCP connections) to the ELB, which load balances the traffic amongst a set of EC2 instances. An ELB can load balance either external traffic from the Internet or, when deployed in a VPC, load balance internal traffic. An ELB also functions as a 
                    <a href="https://microservices.io/patterns/service-registry.html" style="text-decoration: none;" class="external-link" rel="nofollow">Service Registry</a>. EC2 instances are registered with the ELB either explicitly via an API call or automatically as part of an auto-scaling group.
                </p>
                <p>
                    Some clustering solutions such as 
                    <a href="https://github.com/GoogleCloudPlatform/kubernetes/blob/master/docs/services.md" style="text-decoration: none;" class="external-link" rel="nofollow">Kubernetes</a> and 
                    <a style="text-decoration: none;" href="https://mesosphere.github.io/marathon/docs/service-discovery-load-balancing.html" class="external-link" rel="nofollow">Marathon</a> run a proxy on each host that functions as a server-side discovery router. In order to access a service, a client connects to the local proxy using the port assigned to that service. The proxy then forwards the request to a service instance running somewhere in the cluster.
                </p>
                <b>Related Context</b>
                <p>Server-side service discovery has a number of benefits:</p>
                <ul>
                    <li>
                        Compared to 
                        <a href="https://microservices.io/patterns/client-side-discovery.html" style="text-decoration: none;" class="external-link" rel="nofollow">client-side discovery</a>, the client code is simpler since it does not have to deal with discovery. Instead, a client simply makes a request to the router
                    </li>
                    <li>Some cloud environments provide this functionality, e.g. AWS Elastic Load Balancer</li>
                </ul>
                <p>It also has the following drawbacks:</p>
                <ul>
                    <li>Unless it’s part of the cloud environment, the router must is another system component that must be installed and configured. It will also need to be replicated for availability and capacity.</li>
                    <li>The router must support the necessary communication protocols (e.g HTTP, gRPC, Thrift, etc) unless it is TCP-based router</li>
                    <li>
                        More network hops are required than when using 
                        <a style="text-decoration: none;" href="https://microservices.io/patterns/client-side-discovery.html" class="external-link" rel="nofollow">Client Side Discovery</a>
                    </li>
                </ul>
            </div>
        </div>
    </div>
    <div id="footer" role="contentinfo">
        <section class="footer-body">
        </section>
    </div>
</body>
</html>
