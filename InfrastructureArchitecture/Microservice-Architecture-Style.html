<!DOCTYPE html>
<html>
<head>
    <title>Infrastructure Architecture Microservice Architecture Style</title>
    <link rel="stylesheet" href="styles/site.css" type="text/css" />
    <META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</head>
<body>
    
        <div id="main">
            <div id="main-header">
                <div id="breadcrumb-section">
                    <ol id="breadcrumbs">
                        <li>
                            <a href="index.html">Information Technology</a>
                        </li>
                        <li>
                            <a href="2.0-Architectures_451824369.html">2.0 Architectures</a>
                        </li>
                        <li>
                            <a href="451820182.html">Microservices &amp; Distributed System</a>
                        </li>
                        <li>
                            <a href="Microservice-Architecture_451820190.html">Microservice Architecture</a>
                        </li>
                    </ol>
                </div>
                <h1 id="title-heading" class="pagetitle">

                    Infrastructure Architecture Microservice Architecture Style

                </h1>
            </div>
            <div id="content" class="view">
                <p>One challenge with using this approach is deciding when it makes sense to use it. When developing the first version of an application, you often do not have the problems that this approach solves. Moreover, using an elaborate, distributed architecture will slow down development. This can be a major problem for startups whose biggest challenge is often how to rapidly evolve the business model and accompanying application. Using Y-axis splits might make it much more difficult to iterate rapidly. Later on, however, when the challenge is how to scale and you need to use functional decomposition, the tangled dependencies might make it difficult to decompose your monolithic application into a set of services.</p>
                <h2>Constraints Imposed by Microservice Style</h2>
                <p style="margin-left: 0.0px;">By adhering to the following constraints imposed by microservice architecture style, what we get is a system where services can be deployed independently, faults are isolated, frequent updates are possible and it’s easy to introduce new technologies into the application.</p>
                <ul style="margin-left: 15.0px;">
                    <li style="list-style-type: disc;">Each service represents a single responsibility.</li>
                    <li style="list-style-type: disc;">Every service is independent of the others.</li>
                    <li style="list-style-type: disc;">Each service needs its own JVM (or equivalent) so instances are isolated.</li>
                    <li style="list-style-type: disc;">Data is private to the service that owns it.</li>
                    <li style="list-style-type: disc;">Services do not share data and need to implement queries that need to retrieve data owned by multiple services.</li>
                    <li style="list-style-type: disc;">Well defined mechanism to implement service-to-service communication and scheme to deal with partial failure.</li>
                    <li style="list-style-type: disc;">Requests that span multiple services and require careful coordination between the teams.</li>
                    <li style="list-style-type: disc;">Testing to cover the interactions between services.</li>
                    <li style="list-style-type: disc;">Deploying and managing a system comprised of many different services.</li>
                </ul>
                <h2>Consider Challenges Versus Benefits</h2>
                <p style="margin-left: 0.0px;">Each architectural constraint has its own associated challenges/benefits, so it’s important to understand and balance both. Before adopting any style of architecture, you have to ask yourself if the benefits outweigh the challenges for the application you are considering.</p>
                <p style="margin-left: 0.0px;">In the table below, we take a look at the benefits versus challenges of microservice style applications.</p>
                <div class="table-wrap">
                    <table class="confluenceTable">
                        <colgroup>
                            <col />
                            <col />
                        </colgroup>
                        <tbody>
                            <tr>
                                <th style="text-align: left;" class="confluenceTh">
                                    <strong>Benefits</strong>
                                </th>
                                <th style="text-align: left;" class="confluenceTh">
                                    <strong>Challenges</strong>
                                </th>
                            </tr>
                            <tr>
                                <td style="text-align: left;" class="confluenceTd">Enables the continuous delivery and deployment of large, complex applications.</td>
                                <td style="text-align: left;" class="confluenceTd">There is an additional complexity of creating a distributed system.</td>
                            </tr>
                            <tr>
                                <td style="text-align: left;" class="confluenceTd">Improved maintainability: Each service is relatively small so it’s easier to understand and change.</td>
                                <td style="text-align: left;" class="confluenceTd">
                                    Implementing requests that span multiple services is more difficult.
                                    <p style="margin-left: 0.0px;">Maintaining data consistency between service(s) is a challenge.</p>
                                </td>
                            </tr>
                            <tr>
                                <td style="text-align: left;" class="confluenceTd">Better Testability: services are smaller and faster to test.</td>
                                <td style="text-align: left;" class="confluenceTd">Testing the interactions between services is more difficult.</td>
                            </tr>
                            <tr>
                                <td style="text-align: left;" class="confluenceTd">Better deployability: services can be deployed independently.</td>
                                <td style="text-align: left;" class="confluenceTd">Increased operational and deployment complexity of deploying and managing a system comprised of many different services.</td>
                            </tr>
                            <tr>
                                <td style="text-align: left;" class="confluenceTd">Each team can develop, test, deploy and scale their services independently of all of the other teams.</td>
                                <td style="text-align: left;" class="confluenceTd">Implementing requests that span multiple services requires careful coordination between the teams.</td>
                            </tr>
                            <tr>
                                <td style="text-align: left;" class="confluenceTd">Improved fault isolation.</td>
                                <td style="text-align: left;" class="confluenceTd">Inter-service communication and dealing with partial failure implementation is challenging.</td>
                            </tr>
                            <tr>
                                <td style="text-align: left;" class="confluenceTd">Eliminates long-term commitment to a technology stack.</td>
                                <td style="text-align: left;" class="confluenceTd">Overhead of multiple JVM runtimes (or equivalent) and increase in memory consumption needs to be taken care of.</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
                <h2>Scenarios Where You Can Consider Going for Microservice</h2>
                <p style="margin-left: 0.0px;">Consider an scenario where you are developing an enterprise application that must support the following characteristics:</p>
                <ul style="margin-left: 15.0px;">
                    <li style="list-style-type: disc;">Support for different variety of clients that includes desktop browsers, mobile browsers and native mobile applications.</li>
                    <li style="list-style-type: disc;">Expose an API for third parties to consume.</li>
                    <li style="list-style-type: disc;">Integration with other applications via web services or a message broker.</li>
                    <li style="list-style-type: disc;">Run multiple instances of the application on multiple machines to fulfill scalability and availability NFR requirements.</li>
                    <li style="list-style-type: disc;">Adopt emerging technology stack.</li>
                    <li style="list-style-type: disc;">Planning to go for continuous deployment pipeline setup for the application.</li>
                </ul>
                <p style="margin-left: 0.0px;">From the requirements above, you can very well say the application is 100% fit for a microservices architecture.</p>
                <p style="margin-left: 0.0px;">You have to define an architecture that structures the application as a set of loosely coupled, collaborating services. Services can communicate using either synchronous or asynchronous protocols. Services can be developed and deployed independently of one another. Each service has its own database in order to be decoupled from other services.</p>
                <p style="margin-left: 0.0px;">Let’s look at some of the typical scenarios where you can consider going for microservice style of architecture:</p>
                <ol style="margin-left: 15.0px;">
                    <li style="list-style-type: decimal;">Monolithic application migration due to improvements needed in scalability, manageability, agility or speed of delivery.</li>
                    <li style="list-style-type: decimal;">Re-platform a legacy application by transforming functions/modules to microservices.</li>
                    <li style="list-style-type: decimal;">Rewriting legacy application to modern languages, technology stack to meet the demands of modern business.</li>
                    <li style="list-style-type: decimal;">Individual cross-cutting services that are independent in nature. For example: encryption services, authentication services, etc.</li>
                    <li style="list-style-type: decimal;">Independent business applications or services reused across multiple channels. For example, payment services, login services, flight search services, customer profile services, notification services, etc.</li>
                    <li style="list-style-type: decimal;">Commonly used enterprise applications. For example, time tracking application.</li>
                    <li style="list-style-type: decimal;">Scenarios where a service provider makes computing resources and infrastructure management available to the customer as needed. For example, forecasting services, price calculation services, prediction services, etc.</li>
                    <li style="list-style-type: decimal;">Back-end services for responsive client-side web application where data could be coming from multiple channels or different data sources.</li>
                    <li style="list-style-type: decimal;">Highly agile applications or applications demanding speed of delivery or time to market or innovation pilots, etc.</li>
                    <li style="list-style-type: decimal;">Applications that got polyglot, multi-language, cloud application development.</li>
                </ol>
            </div>
        </div>
    <div id="footer" role="contentinfo">
        <section class="footer-body">
        </section>
    </div>
</body>
</html>
