<!DOCTYPE html>
<html>
<head>
    <title>Infrastructure Architecture Queue-Based Load Leveling Pattern</title>
    <link rel="stylesheet" href="styles/site.css" type="text/css" />
    <META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</head>
<body class="theme-default aui-theme-default">
    <div id="page">
        <div id="main" class="aui-page-panel">
            <div id="main-header">
                <div id="breadcrumb-section">
                    <ol id="breadcrumbs">
                        <li>
                            <a href="index.html">Information Technology</a>
                        </li>
                        <li>
                            <a href="2.0-Architectures_451824369.html">2.0 Architectures</a>
                        </li>
                        <li>
                            <a href="Infrastructure-Design-Patterns_463533493.html">Infrastructure Design Patterns</a>
                        </li>
                    </ol>
                </div>
                <h1 id="title-heading" class="pagetitle">
                    Infrastructure Architecture Queue-Based Load Leveling Pattern
                </h1>
            </div>
            <div id="content" class="view">
                <h2>Overview</h2>
                <p>Use a queue that acts as a buffer between a task and a service it invokes in order to smooth intermittent heavy loads that can cause the service to fail or the task to time out. This can help to minimize the impact of peaks in demand on availability and responsiveness for both the task and the service.</p>
                <h2>Context and Problem</h2>
                <p>Many solutions in the cloud involve running tasks that invoke services. In this environment, if a service is subjected to intermittent heavy loads, it can cause performance or reliability issues.</p>
                <p>A service could be part of the same solution as the tasks that use it, or it could be a third-party service providing access to frequently used resources such as a cache or a storage service. If the same service is used by a number of tasks running concurrently, it can be difficult to predict the volume of requests to the service at any time.</p>
                <p>A service might experience peaks in demand that cause it to overload and be unable to respond to requests in a timely manner. Flooding a service with a large number of concurrent requests can also result in the service failing if it's unable to handle the contention these requests cause.</p>
                <h2>Solution</h2>
                <p>Refactor the solution and introduce a queue between the task and the service. The task and the service run asynchronously. The task posts a message containing the data required by the service to a queue. The queue acts as a buffer, storing the message until it's retrieved by the service. The service retrieves the messages from the queue and processes them. Requests from a number of tasks, which can be generated at a highly variable rate, can be passed to the service through the same message queue. This figure shows using a queue to level the load on a service.</p>
                <p style="margin-left: 30.0px;">
                    <img class="confluence-embedded-image confluence-content-image-border" height="150" src="attachments/463533393/463533392.png" data-image-src="attachments/463533393/463533392.png" data-unresolved-comment-count="0" data-linked-resource-id="463533392" data-linked-resource-version="1" data-linked-resource-type="attachment" data-linked-resource-default-alias="queue-based-load-leveling-pattern.png" data-base-url="https://wiki.pinnacle.com" data-linked-resource-content-type="image/png" data-linked-resource-container-id="463533393" data-linked-resource-container-version="1">
                </p>
                <p>The queue decouples the tasks from the service, and the service can handle the messages at its own pace regardless of the volume of requests from concurrent tasks. Additionally, there's no delay to a task if the service isn't available at the time it posts a message to the queue.</p>
                <p>This pattern provides the following benefits:</p>
                <ul>
                    <li>
                        <p>It can help to maximize availability because delays arising in services won't have an immediate and direct impact on the application, which can continue to post messages to the queue even when the service isn't available or isn't currently processing messages.</p>
                    </li>
                    <li>
                        <p>It can help to maximize scalability because both the number of queues and the number of services can be varied to meet demand.</p>
                    </li>
                    <li>
                        <p>It can help to control costs because the number of service instances deployed only have to be adequate to meet average load rather than the peak load.</p>
                        <blockquote>
                            <p>Some services implement throttling when demand reaches a threshold beyond which the system could fail. Throttling can reduce the functionality available. You can implement load leveling with these services to ensure that this threshold isn't reached.</p>
                        </blockquote>
                    </li>
                </ul>
                <h2>Issues and Considerations</h2>
                <p>Consider the following points when deciding how to implement this pattern:</p>
                <ul>
                    <li>It's necessary to implement application logic that controls the rate at which services handle messages to avoid overwhelming the target resource. Avoid passing spikes in demand to the next stage of the system. Test the system under load to ensure that it provides the required leveling, and adjust the number of queues and the number of service instances that handle messages to achieve this.</li>
                    <li>
                        Message queues are a one-way communication mechanism. If a task expects a reply from a service, it might be necessary to implement a mechanism that the service can use to send a response. For more information, see the 
                        <a style="text-decoration: none;" href="https://msdn.microsoft.com/library/dn589781.aspx" class="external-link" rel="nofollow">Asynchronous Messaging Primer</a>.
                    </li>
                    <li>Be careful if you apply autoscaling to services that are listening for requests on the queue. This can result in increased contention for any resources that these services share and diminish the effectiveness of using the queue to level the load.</li>
                </ul>
                <h2>When to use this Pattern</h2>
                <p>This pattern is useful to any application that uses services that are subject to overloading.</p>
                <p>This pattern isn't useful if the application expects a response from the service with minimal latency.</p>
            </div>
        </div>
        <div id="footer" role="contentinfo">
            <section class="footer-body">
            </section>
        </div>
    </div>
</body>
</html>
