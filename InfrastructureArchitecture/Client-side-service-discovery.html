<!DOCTYPE html>
<html>
<head>
    <title>Infrastructure Architecture Client-side service discovery</title>
    <link rel="stylesheet" href="styles/site.css" type="text/css" />
    <META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</head>
<body>
    
        <div id="main">
            <div id="main-header">
                <div id="breadcrumb-section">
                    <ol id="breadcrumbs">
                        <li>
                            <a href="index.html">Information Technology</a>
                        </li>
                        <li>
                            <a href="2.0-Architectures_451824369.html">2.0 Architectures</a>
                        </li>
                        <li>
                            <a href="451820182.html">Microservices &amp; Distributed System</a>
                        </li>
                        <li>
                            <a href="Microservice-Architecture_451820190.html">Microservice Architecture</a>
                        </li>
                    </ol>
                </div>
                <h1 id="title-heading" class="pagetitle">

                    Infrastructure Architecture Client-side service discovery

                </h1>
            </div>
            <div id="content" class="view">
                <h2>Context</h2>
                <p>
                    Services typically need to call one another. In a monolithic application, services invoke one another through language-level method or procedure calls. In a traditional distributed system deployment, services run at fixed, well known locations (hosts and ports) and so can easily call one another using HTTP/REST or some RPC mechanism. However, a modern 

                    <a href="https://microservices.io/patterns/microservices.html" style="text-decoration: none;" class="external-link" rel="nofollow">microservice-based</a> application typically runs in a virtualized or containerized environments where the number of instances of a service and their locations changes dynamically.

                </p>
                <p style="margin-left: 30.0px;">
                    <img class="confluence-embedded-image img-responsive confluence-external-resource confluence-content-image-border" height="250" src="https://microservices.io/i/servicediscovery/discovery-problem.jpg" data-image-src="https://microservices.io/i/servicediscovery/discovery-problem.jpg">
                </p>
                <p>Consequently, you must implement a mechanism for that enables the clients of service to make requests to a dynamically changing set of ephemeral service instances.</p>
                <h2>Problem</h2>
                <p>How does the client of a service - the API gateway or another service - discover the location of a service instance?</p>
                <h2>Forces</h2>
                <ul>
                    <li>Each instance of a service exposes a remote API such as HTTP/REST, or Thrift etc. at a particular location (host and port)</li>
                    <li>The number of services instances and their locations changes dynamically.</li>
                    <li>Virtual machines and containers are usually assigned dynamic IP addresses.</li>
                    <li>The number of services instances might vary dynamically. For example, an EC2 Autoscaling Group adjusts the number of instances based on load.</li>
                </ul>
                <h2>Solution</h2>
                <p>
                    When making a request to a service, the client obtains the location of a service instance by querying a 

                    <a style="text-decoration: none;" href="https://microservices.io/patterns/service-registry.html" class="external-link" rel="nofollow">Service Registry</a>, which knows the locations of all service instances.

                </p>
                <p>The following diagram shows the structure of this pattern.</p>
                <p style="margin-left: 30.0px;">
                    <img class="confluence-embedded-image img-responsive confluence-external-resource confluence-content-image-border" height="250" src="https://microservices.io/i/servicediscovery/client-side-discovery.jpg" data-image-src="https://microservices.io/i/servicediscovery/client-side-discovery.jpg">
                </p>
                <p>
                    This is typically handled by a 

                    <a style="text-decoration: none;" href="https://microservices.io/patterns/microservice-chassis.html" class="external-link" rel="nofollow">Microservice chassis framework</a>
                </p>
                <h2>Examples</h2>
                <p>
                    The 

                    <a style="text-decoration: none;" href="https://github.com/cer/microservices-examples" class="external-link" rel="nofollow">Microservices Example application</a> is an example of an application that uses client-side service discovery. It is written in Scala and uses Spring Boot and Spring Cloud as the 

                    <a href="https://microservices.io/patterns/microservice-chassis.html" style="text-decoration: none;" class="external-link" rel="nofollow">Microservice chassis</a>. They provide various capabilities including client-side discovery.

                </p>
                <h2>Resulting Context</h2>
                <p>Client-side discovery has the following benefits:</p>
                <ul>
                    <li>
                        Fewer moving parts and network hops compared to 
                        <a style="text-decoration: none;" href="https://microservices.io/patterns/server-side-discovery.html" class="external-link" rel="nofollow">Server-side Discovery</a>
                    </li>
                </ul>
                <p>Client-side discovery also has the following drawbacks:</p>
                <ul>
                    <li>
                        This pattern couples the client to the 
                        <a style="text-decoration: none;" href="https://microservices.io/patterns/service-registry.html" class="external-link" rel="nofollow">Service Registry</a>
                    </li>
                    <li>
                        You need to implement client-side service discovery logic for each programming language/framework used by your application, e.g Java/Scala, JavaScript/NodeJS. For example, 
                        <a style="text-decoration: none;" href="https://github.com/Netflix/Prana" class="external-link" rel="nofollow">Netflix Prana</a> provides an HTTP proxy-based approach to service discovery for non-JVM clients.
                    </li>
                </ul>
            </div>
        </div>
    <div id="footer" role="contentinfo">
        <section class="footer-body">
        </section>
    </div>
</body>
</html>
